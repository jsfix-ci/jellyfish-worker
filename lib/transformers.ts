import { getLogger } from '@balena/jellyfish-logger';
import type { LogContext } from '@balena/jellyfish-logger';
import type { Contract, JsonSchema, TypeContract } from 'autumndb';
import _ from 'lodash';
import * as skhema from 'skhema';
import { v4 as uuidv4 } from 'uuid';
import type { ProducerResults } from './queue';
import type { TransformerContract } from './types';

const logger = getLogger('worker');

export interface EvaluateOptions {
	transformers: TransformerContract[];
	oldContract: Contract<any> | null;
	newContract: Contract<any>;
	logContext: LogContext;
	getTypeContract: (type: string) => TypeContract;
	query: (
		schema: JsonSchema,
		opts: { sortBy?: string; sortDir?: 'asc' | 'desc'; limit?: number },
	) => Promise<Contract[]>;
	// TS-TODO: Make slug optional in core model
	executeAndAwaitAction: (
		actionRequest: Partial<Contract>,
	) => Promise<ProducerResults>;
}

// TS-TODO: Transformers should be a default model and included in this module
export const evaluate = async ({
	transformers,
	oldContract,
	newContract,
	logContext,
	getTypeContract,
	query,
	executeAndAwaitAction,
}: EvaluateOptions): Promise<null> => {
	if (!transformers || !Array.isArray(transformers)) {
		logger.info(logContext, 'No transformers');
		return null;
	}

	// Only run transformers with contracts with a valid artifact or which do not have artifacts at all
	// and their input filter matches now, but didn't match before (or artifact wasn't ready)
	const readyNow = newContract.data?.$transformer?.artifactReady;
	if (readyNow === false) {
		logger.info(logContext, 'Transformer artifact not ready', {
			oldContract: {
				id: oldContract?.id,
				type: oldContract?.type,
			},
			newContract: {
				id: newContract.id,
				type: newContract.type,
			},
		});
		return null;
	}
	const artifactReadyChanged =
		oldContract?.data?.$transformer?.artifactReady !== readyNow;

	const results = await Promise.all(
		transformers.map(async (transformer: TransformerContract) => {
			if (!transformer.data.inputFilter) {
				return false;
			}
			// TODO: Allow transformer input filter to match $$links, by re-using the trigger filter
			const matchesNow = skhema.isValid(
				transformer.data.inputFilter,
				newContract,
			);
			const matchedPreviously = skhema.isValid(
				transformer.data.inputFilter,
				oldContract || {},
			);

			const shouldRun =
				matchesNow && (!matchedPreviously || artifactReadyChanged);

			if (!shouldRun) {
				return false;
			}

			const transformerActor = await getTransformerActor(query, transformer);
			if (!transformerActor) {
				logger.warn(
					logContext,
					'Cannot run transformer that does not have an owner',
					{
						id: transformer.id,
						slug: transformer.slug,
						version: transformer.version,
					},
				);
				return false;
			}

			// Re enqueue an action request to call the matchmaking function
			// TODO: link task to origin transformer
			logger.info(logContext, 'Creating transformer task', {
				transformer: {
					id: transformer.id,
					slug: transformer.slug,
					version: transformer.version,
					actor: transformerActor.id,
				},
				newContract: {
					id: newContract.id,
					type: newContract.type,
				},
				oldContract: {
					id: oldContract?.id,
					type: oldContract?.type,
				},
			});

			const date = new Date();
			const result: any = await executeAndAwaitAction({
				data: {
					card: getTypeContract('task@1.0.0'),
					action: 'action-create-card@1.0.0',
					actor: transformerActor.id,
					context: logContext,
					input: {
						id: getTypeContract('task@1.0.0').id,
					},
					epoch: date.valueOf(),
					timestamp: date.toISOString(),
					arguments: {
						reason: null,
						properties: {
							name: `Transform ${newContract.name} using transformer ${transformer.name}`,
							data: {
								status: 'pending',
								input: newContract,
								transformer,
								actor: transformerActor.id,
								workerFilter: {
									schema: transformer.data.workerFilter,
								},
							},
						},
					},
				},
			});

			// TODO: Improve core API for linking contracts
			await executeAndAwaitAction({
				data: {
					card: getTypeContract('link@1.0.0').id,
					action: 'action-create-card@1.0.0',
					actor: transformerActor.id,
					context: logContext,
					input: {
						id: getTypeContract('link@1.0.0').id,
					},
					epoch: date.valueOf(),
					timestamp: date.toISOString(),
					arguments: {
						reason: null,
						properties: {
							slug: `link-${transformer.id}-generated-${
								result.data.id
							}-${uuidv4()}`,
							name: 'generated',
							data: {
								inverseName: 'was generated by',
								from: {
									id: transformer.id,
									type: transformer.type,
								},
								to: {
									id: result.data.id,
									type: result.data.type,
								},
							},
						},
					},
				},
			});

			return readyNow;
		}),
	);

	if (!results.includes(true)) {
		logger.info(logContext, 'Did not execute any transformers', {
			newContract: {
				id: newContract.id,
				type: newContract.type,
			},
			oldContract: {
				id: oldContract?.id,
				type: oldContract?.type,
			},
		});
	}
	return null;
};

async function getTransformerActor(
	query: (
		schema: any,
		opts: {
			sortBy?: string;
			sortDir?: 'asc' | 'desc';
			limit?: number;
		},
	) => Promise<Contract[]>,
	transformer: TransformerContract,
) {
	// The transformer should be run on behalf of the actor that owns the
	// transformer
	const [transformerOwner] = await query(
		{
			type: 'object',
			properties: {
				active: {
					const: true,
				},
			},
			$$links: {
				owns: {
					type: 'object',
					properties: {
						id: {
							const: transformer.id,
						},
					},
				},
			},
		},
		{
			limit: 1,
		},
	);

	if (transformerOwner) {
		return transformerOwner;
	}

	// Or by the actor that owns its contract-repository
	const [repoOwner] = await query(
		{
			type: 'object',
			properties: {
				active: {
					const: true,
				},
			},
			$$links: {
				owns: {
					type: 'object',
					required: ['type', 'data'],
					properties: {
						type: {
							const: 'contract-repository@1.0.0',
						},
						active: {
							const: true,
						},
						data: {
							type: 'object',
							required: ['base_slug'],
							properties: {
								base_slug: {
									const: transformer.slug,
								},
							},
						},
					},
				},
			},
		},
		{
			limit: 1,
		},
	);
	return repoOwner;
}
