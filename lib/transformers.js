/*
 * Copyright (C) Balena.io - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 */

const Bluebird = require('bluebird')
const _ = require('lodash')
const skhema = require('skhema')
const uuid = require('@balena/jellyfish-uuid')
const logger = require('@balena/jellyfish-logger').getLogger(__filename)

exports.evaluate = ({
	transformers,
	oldCard,
	newCard,
	context,
	query,
	executeAndAwaitAction
}) => {
	if (!transformers || !Array.isArray(transformers)) {
		return null
	}

	if (!oldCard) {
		return null
	}

	// Only evaluate transformers if `data.$transformer.artifactReady` has been toggled to true,
	// indicating that the corresponding artefact is available in the registry
	if (
		_.get(oldCard.data, [ '$transformer', 'artifactReady' ]) !== true &&
		_.get(newCard.data, [ '$transformer', 'artifactReady' ]) === true) {
		return Bluebird.map(transformers, async (transformer) => {
			// TODO: Allow transformer input filter to match $$links, by re-using the trigger filter
			const match = transformer.data.inputFilter && skhema.isValid(transformer.data.inputFilter, newCard)

			if (match) {
				// The transformer should be run on behalf of the actor that owns the
				// transformer
				const [ transformerOwner ] = await query(transformerOwnerQuery(transformer), {
					limit: 1
				})

				let transformerActor = transformerOwner

				// Or by the actor that owns its contract-repository
				if (!transformerActor) {
					const [ repoOwner ] = await query(contractRepoOwnerQueryFromTransformer(transformer), {
						limit: 1
					})
					transformerActor = repoOwner
				}

				if (transformerActor) {
					let workerQuery = transformer.data.workerFilter
					if (!workerQuery) {
						// We assume specifying neither workerFilter nor requirements, the users wants
						// "sensible defaults", which probably means x86_64
						workerQuery = workerQueryFromRequirements(transformer.data.requirements || {
							architecture: 'x86_64'
						})
					}
					const createTaskActionRequest = {
						card: 'task@1.0.0',
						type: 'type',
						action: 'action-create-card@1.0.0',
						actor: transformerActor.id,
						arguments: {
							reason: null,
							properties: {
								name: `Transform ${newCard.id} using transformer ${transformer.id}`,
								data: {
									status: 'pending',
									input: newCard,
									transformer,
									actor: transformerActor.id,
									workerFilter: {
										schema: workerQuery
									}
								}
							}
						}
					}

					// Re enqueue an action request to call the matchmaking function
					// TODO: link task to origin transformer
					const result = await executeAndAwaitAction(createTaskActionRequest)

					// TODO: Improve core API for linking cards
					await executeAndAwaitAction({
						card: 'link@1.0.0',
						type: 'type',
						action: 'action-create-card@1.0.0',
						actor: transformerActor.id,
						arguments: {
							reason: null,
							properties: {
								type: 'link@1.0.0',
								slug: `link-${transformer.id}-generated-${result.data.id}-${await uuid.random()}`,
								name: 'generated',
								data: {
									inverseName: 'was generated by',
									from: {
										id: transformer.id,
										type: transformer.type
									},
									to: {
										id: result.data.id,
										type: result.data.type
									}
								}
							}
						}
					})
				} else {
					logger.warn(context, 'Cannot run transformer that does not have an owner', {
						transformer: transformer.id
					})
				}
			}
		})
	}
	return null
}

const workerQueryFromRequirements = (requirements) => {
	const requirementsAsSchema = Object.entries(requirements)
		.reduce((prop, [ key, val ]) => {
			return {
				...prop,
				[key]: {
					const: val
				}
			}
		}, {})
	const workerQuery = {
		type: 'object',
		required: [ 'type', 'data' ],
		properties: {
			type: {
				const: 'transformer-worker@1.0.0'
			},
			data: {
				type: 'object',
				required: Object.keys(requirements),
				properties: requirementsAsSchema
			}
		}
	}
	return workerQuery
}

const contractRepoOwnerQueryFromTransformer = (transformer) => {
	return {
		type: 'object',
		properties: {
			active: {
				const: true
			}
		},
		$$links: {
			owns: {
				type: 'object',
				required: [ 'type', 'data' ],
				properties: {
					type: {
						const: 'contract-repository@1.0.0'
					},
					active: {
						const: true
					},
					data: {
						type: 'object',
						required: [ 'base_slug' ],
						properties: {
							base_slug: {
								const: transformer.slug
							}
						}
					}
				}
			}
		}
	}
}

const transformerOwnerQuery = (transformer) => {
	return {
		type: 'object',
		properties: {
			active: {
				const: true
			}
		},
		$$links: {
			owns: {
				type: 'object',
				properties: {
					id: {
						const: transformer.id
					}
				}
			}
		}
	}
}
